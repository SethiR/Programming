#+AUTHOR:      Rajat Sethi

* Bytes 

Strings are sequences which are immutable and store only unicode texts. =Bytes= and mutatble alternative =bytearray= store only bytes as sequence values. (which are 0 <= x <= 256).

#+BEGIN_SRC python :results output :exports both
  print(list(b'foo bar')) # use b to convert to byte
  print(tuple(b'foo bar'))
#+END_SRC

#+RESULTS:
: [102, 111, 111, 32, 98, 97, 114]
: (102, 111, 111, 32, 98, 97, 114)


#+BEGIN_SRC python :results output :exports both
  print(bytes([100,101,102, 103]))
#+END_SRC

#+RESULTS:
: b'defg'

The bytes and bytearray allow to work with raw binary data e.g. image files, video, audio and network packets etc...

You can create a bytearray using bytearray constructor like this =bytearray(b'foo bar')=

There are various other things you can do with bytes and bytes arrays which you can check out online.

#+BEGIN_SRC python :results output :exports both
#+END_SRC


#+BEGIN_SRC python :results output :exports both
#+END_SRC


#+BEGIN_SRC python :results output :exports both
#+END_SRC


#+BEGIN_SRC python :results output :exports both
#+END_SRC


#+BEGIN_SRC python :results output :exports both
#+END_SRC


#+BEGIN_SRC python :results output :exports both
#+END_SRC


#+BEGIN_SRC python :results output :exports both
#+END_SRC


#+BEGIN_SRC python :results output :exports both
#+END_SRC

* List

** Slicing

For slicing with [start:stop:increment] under the hood python calls =seq.__getitem__(slice(start, stop, step))=

By using the above knowledge we can define our own named slices and make the code more elegant.


#+BEGIN_SRC python :results output :exports both


>>> data = """
1010 CA Ontario
1020 US New York
1030 IN Delhi
"""
>>> ID = slice(0, 4)
>>> COUNTRY = slice(5,7)
>>> 
>>> for row in data.split("\n"):
	print(row[ID])

1010
1020
1030

#+END_SRC


*=__getitem__ and __setitem__=*

The [] operator is handled by getitem and setitem. In other words, to evaluate a[i, j], Python calls =a.__getitem__((i, j))=.

** Implementation Details

Lists in Python are contiguous arrays of references to other objects. The head of the list stores the pointer to this list and its length.

* Dict

- They are highliy optimized.
- Are based on hash tables - Thus only objects which are hashable can be used as keys. The =__hash__= data model method provides the hash value of an object.


*dict comprehension*

they are similar to list comprehension


*Variations of dict*__*
- dict
- defualtdict
- ordereddict
- collections.ChainMap
- collections.Counter
- collections.UserDict
- types.mappingproxy

`collections.UserDict` is designed to be subclassed, an example below.


#+BEGIN_SRC python :results output :exports both
  class StrKeyDict(collections.UserDict):
    def __missing__(self, key):
        if isinstance(key, str):
          raise KeyError(key)
        return self[str(key)]

    def __contains__(self, key):
        return str(key) in self.data
    
    def __setitem__(self, key, item):
        self.data[str(key)] = item
#+END_SRC

*=setdefualt()=*

#+BEGIN_SRC python :results output :exports both
#+END_SRC

#+BEGIN_SRC python :results output :exports both
>>> d = {'Name': 'Zara', 'Age': 7}
>>> d.setdefault("Sex", None)
>>> d
{'Name': 'Zara', 'Age': 7, 'Sex': None}
>>> d.setdefault("Name", 'Peter')
'Zara'
>>> d
{'Name': 'Zara', 'Age': 7, 'Sex': None}
#+END_SRC

** Defaultdict

Defualt dict is very similar to `dict` but you can pass a callable that is used to produce a default value whenever =__getitem__= is passed a nonexistant key.

#+BEGIN_SRC python :results output :exports both
>>> s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
>>> d = defaultdict(list)
>>> for k, v in s:
...     d[k].append(v)
...
>>> sorted(d.items())
[('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]
#+END_SRC


Dict's are very fast but they do consume lots of memory becasue they need hash tables to operate which should be sparsely populated. If you are processing large amounts of data you should create them as rows of tuples/named tuples vs creating them as arrays of dicts (JSON) for space considerations.

Check out the `__slots__` attribute which changes the storage of instance attributes from a dict to a tuple in each instance.

The dict implementation is an example of trading space for time: dictionaries have significant memory overhead, but they provide fast access regardless of the size of the dictionary—as long as it fits in memory. 




Dictionaries are a keystone of Python. Beyond the basic dict, the standard library offers
handy, ready-to-use specialized mappings like defaultdict, OrderedDict, ChainMap,
and Counter, all defined in the collections module. The same module also provides
the easy-to-extend UserDict class.
Two powerful methods available in most mappings are setdefault and update. The
setdefault method is used to update items holding mutable values, for example, in a
dict of list values, to avoid redundant searches for the same key. The update method
allows bulk insertion or overwriting of items from any other mapping, from iterables
providing (key, value) pairs and from keyword arguments. Mapping constructors
also use update internally, allowing instances to be initialized from mappings, iterables,
or keyword arguments.
A clever hook in the mapping API is the __missing__ method, which lets you customize
what happens when a key is not found.
The collections.abc module provides the Mapping and MutableMapping abstract base
classes for reference and type checking. The little-known MappingProxyType from the
types module creates immutable mappings. There are also ABCs for Set and Mutable
* Slots

=__slots__= can save space if you are dealing with millions of instances with few attributes. (They use tuples instead of the standard =__dict__= to store the instance attributes.)

#+BEGIN_SRC python :results output :exports both

class Vector2d:
    __slots__ = ('__x', '__y')
#+END_SRC

Slots will treat =x= and =y= as instance variables.

There are some considerations which come with =__slots__= like cannot add other instance variables unless you add =__dict__= to slots and cannot use weakref unless you add =__weakref__= to slots.
* weakref

A weak reference to an object is not enough to keep the object alive: when the only remaining references to a referent are weak references, garbage collection is free to destroy the referent and reuse its memory for something else. However, until the object is actually destroyed the weak reference may return the object even if there are no strong references to it.

A primary use for weak references is to implement caches or mappings holding large objects, where it’s desired that a large object not be kept alive solely because it appears in a cache or mapping.

WeakKeyDictionary, WeakValueDictionary, WeakSet, and finalize (which use weak references internally) instead of creating and handling your own weak ref.ref instances by hand.

* Subclassing built-ins
Its not a good idea to subclass the builtins like `dict` and `list` because they ignore the user defined functions, instead you should subclass the collections module using UserDict, UserList, and
UserString, which are designed to be easily extended.

* Arrays

Use arrays (which are as lean as the arrays in language C) if - The list
will contain only numbers

You need to specify the =type= when creating the array.

Functions to read and write data from and to array are easy and very
fast as compared to reading/writing text files. (upto 60 times faster) -
Array.tofile - Array.fromfile

*Creating a simple Array*

#+BEGIN_SRC python :results output :exports both
    from array import array

    floats = array('d', (10.1, 10.2))  # array('d', [10.1, 10.2])

    print(floats)
#+END_SRC

*Saving data in file*

#+BEGIN_SRC python :results output :exports both

    from array import array
    from random import random

    data = array('d', (10.1, 10.2))

    # Write to file.
    fp = open('data.bin', 'wb')
    data.tofile(fp)
    fp.close()
#+END_SRC

*Reading data from file*

You can use =array.fromfile(f, n)= where =f= is file and =n= is number
of items. (Yes you need to know the number of items.) Check other
methods [[https://docs.python.org/3/library/array.html][here]]
* Enum

Enum is supported by many languages such as C, C++, Java etc... Below is
a very brief overview, there is a lot more going on with them so check
out this [[https://docs.python.org/3/library/enum.html][link]]

Creating an enum

#+BEGIN_SRC python
    from enum import Enum

    class Weekday(Enum):
        MONDAY = 0
        TUESDAY = 1
#+END_SRC

#+BEGIN_SRC python
    >>> print(Weekday.MONDAY)
    Weekday.MONDAY
#+END_SRC

The enums are hashable so they can be used as dictionary keys.

#+BEGIN_SRC python
    >>> print(Weekday(1))
    Weeksay.TUESDAY
#+END_SRC

You can use the decorator =@enum.unique= to ensure that enum values are
unique.

* Isolating Envirounments in Python
Sometimes pip is not install on linux based system even if python is
installed. In these cases you can install pip for python3 by using the
following command.

#+BEGIN_SRC sh
    sudo apt install python3-pip
#+END_SRC

Getting details of pip.

#+BEGIN_SRC sh
    pip3 show pip
#+END_SRC

Installing system-wide packages directly from PyPI is not recommended,
and should be avoided.

The dependencies should be isolated. There are 2 types of isolations -
Application level isolation - Venv - System level isolation - VMWare,
virtualbox, docker

--------------

Using =venv=

Create a python envirounment using =venv=

#+BEGIN_SRC sh
    python3 -m venv ENV
#+END_SRC

This will create a folder name ENV which will store the python
envirounment.

You can activate it using the following command.

#+BEGIN_SRC sh
    source ENV/bin/activate
#+END_SRC

After this your prompt will change =(ENV) ➜  ENV= which means you have
activate it.

Once you install packages using pip3 in your local ENV you can see the
packages installed using the following command. =pip3 freeze=

To store the list of packages in a requirements.txt file so that the
envirounment can be created again on another machine if required.

Pipe the output of =pip3 freeze= into that text file.

#+BEGIN_EXAMPLE
    pip3 freeze > requirements.txt
#+END_EXAMPLE

Your text file will look something like below stating each package
installed on that env. Remember =pip3 freeze= does not know which
package is being used or not. It just compiles a list of packages
installed.

#+BEGIN_EXAMPLE
    click==7.1.2
    Flask==1.1.2
    itsdangerous==1.1.0
    Jinja2==2.11.2
    MarkupSafe==1.1.1
    Werkzeug==1.0.1
#+END_EXAMPLE

To create the same envirounment you can use the command.

#+BEGIN_EXAMPLE
    pip3 install -r requirements.txt
#+END_EXAMPLE

You can also deactivate using that python implementation by using
command =pip3 freeze=


* Tuples

** Tuple unpacking

#+BEGIN_SRC python
    >>> student1 = ("Sam", 14, 8)
    >>> name, age, grade = student1 # tuple unpacking
    >>> name
    'Sam'
    >>> age
    14
    >>> grade
    8
#+END_SRC

Tuple unpacking can also be used to return/accept multiple values from a
function.

#+BEGIN_SRC python
    def return2():
        return 'a', 'b'

    >>> return2()
    ('a', 'b')
    >>> val1, val2 = return2()
    >>> val1
    'a'
    >>> val2
    'b'
#+END_SRC

Use * for extra values. The =*= does not need to be the last parameter.

#+BEGIN_SRC python
    >>> a, b, *rest = range(1, 5)
    >>> a, b, rest
    (1, 2, [3, 4])
#+END_SRC


* Sets

They are implemented very similiarly to dictionaries. The key is the
element itself. Sets allow for very fast addition, deletion and checking
for existance.

** Set

A set is a collection of unique objects. A set is mutable.

/Creating a set/

#+BEGIN_SRC python
    >>> a = {'a', 'b'}
    >>> type(a)
    <class 'set'>
#+END_SRC

- Intersection =a & b=
- Union =a | b=
- Difference =a - b=

#+BEGIN_SRC python
    >>> foods = {"chicken", "bread", "tomatao", "onions"}
    >>> veges = {"tomatao", "onions"}
    >>> 
    >>> foods - veges
    {'bread', 'chicken'}
    >>> 
    >>> foods & veges
    {'tomatao', 'onions'}
#+END_SRC

You cannot create an empty set like this ={}=, empty set needs to be
created with a constructor like =s = set()=.

Sets are also implemented with hash tables in the background, the value
is hashed and stored (so we have unique values). Similar to dicts they
are fast in membership testing but not so good on memory.

** Frozen Set
   :PROPERTIES:
   :CUSTOM_ID: frozen-set
   :END:

A frozenset is immutable and thus hashable. You can create a frozenset
as shown below.

#+BEGIN_SRC python
    >>> x = frozenset({1, 2, 3})

    >>> type(x)
    <class 'frozenset'>

    >>> x.__hash__()
    -272375401224217160
#+END_SRC

* MRO

=Class.__mro__= will give you the method resolution order of that class.
This is useful in figuring out the multiple inheritance MRO.


* Generator

** Background of Iterators

How re works

#+BEGIN_SRC python
    import re
    w = re.compile('\w+')
    w.findall("This is word")  # ['This', 'is', 'word']
#+END_SRC

#+BEGIN_SRC python
    import re

    RE_WORD = re.compile('\w+')

    # The below class implements the necessary methods for sequence.
    class Sentence:
        
        def __init__(self, text):
            self.text = text
            self.word = RE_WORD.findall(self.text)
            
        def __getitem__(self, index):
            return self.word[index]
            
        def __len__(self):
            return len(self.words)
#+END_SRC

#+BEGIN_SRC python
    s1 = Sentence("The quick brown fox jumped over the lazy dog")

    for word in s1:
        print(word)
#+END_SRC

#+BEGIN_EXAMPLE
    The
    quick
    brown
    fox
    jumped
    over
    the
    lazy
    dog
#+END_EXAMPLE

*Why sequences are iterable even though we did not implement the
=__iter__= method ?*

- Whenver we try to iterate over an object by using lets say for loop or
  any other method the python calls the =iter(object)=
- The built in =iter= funtion then checks the following : -

  - Is =__iter__= implement for that object?
  - If no then it falls back on =__getitem__= and creates an iterator on
    top of that starting form index 0
  - If that fails too raise TypeError

- Generally a good idea to implement =__iter__= too. =__getietm__= only
  works for backward compatability.

*What is iterable* ?

Anything which can be iterated on, which can be done in couple of ways

- Objects implementing =__iter__=
- Objects which are sequences i.e. implementing =__getitem__=

*What is iterator then ?*

Python obtains iterator from iterables....

#+BEGIN_SRC python
    iter(s1)  # This will give you an iterator.
#+END_SRC

#+BEGIN_EXAMPLE
    <iterator at 0x629e790>
#+END_EXAMPLE

*Iterator Details*

The iterator should have the following methods implemented.

- =__iter__= - Returns self; this allows iterators to be used where an
  iterable is expected, for example, in a for loop.
- =__next__= - Returns the next available item and takes no arguments,
  raising StopIteration when there are no more items.

Once all the items are exhausted you need to call =iter(object)= again.

Converting our Sentence class into iterator by implementing the next and
iter methods. However this is a bad idea.

#+BEGIN_SRC python
    import re

    RE_WORD = re.compile('\w+')

    # The below class implements the necessary methods for sequence.
    class Sentence:
        
        def __init__(self, text):
            self.text = text
            self.word = RE_WORD.findall(self.text)
            self.index = 0
            
        def __next__(self):
            try:
                word = self.word[self.index]
            except:
                raise StopIteration()
            self.index += 1
            return word
        
        def __iter__(self):
            return self
#+END_SRC

#+BEGIN_SRC python
    s = Sentence("Hello World today is Monday")

    iter1 = iter(s)
    iter2 = iter(s)

    print(next(iter1))
    print(next(iter2))  # So we have a problem here, we cannot have 2 iterators on the s object individually.
#+END_SRC

#+BEGIN_EXAMPLE
    Hello
    World
#+END_EXAMPLE

The best way to solve this would be to have 2 classes - our normal
Sentence class --> will have the =__iter__= method which will return a
new instance of SentenceIterator class =SentenceIterator(self.words)=
every time =iter= is called on the =Sentence= class thus making sure
each iterator has independent execution. - Sentence iterator class -->
will have the =__iter__= method which will return =self= and the
=__next__= method for raising StopException and taking index into
account.

However this is a much long winded approach.

--------------

** Generators


#+BEGIN_QUOTE
  Check out [[https://www.python.org/dev/peps/pep-0255/][Pep 255]]
#+END_QUOTE

*What is a generator ?*

A python function which has yeild in its body is a generator function.
(It will return a generator object). In other words, a generator
function is a generator factory. A generator function builds a generator
object and wraps the body of the function in it.

Convert *iter* to a generator object.

#+BEGIN_SRC python
    # A simple generator

    def my_generator():
        yield 1
        print("printing --> 1")
        yield 2
        print("printing --> 2")
        yield 3
        print("printing --> 3")
        return None
#+END_SRC

#+BEGIN_SRC python
    # explicit next

    g1 = my_generator()
    print(f"Generator object --> {g1}")

    print(next(g1))
    print(next(g1))
    print(next(g1))
#+END_SRC

#+BEGIN_EXAMPLE
    Generator object --> <generator object my_generator at 0x00BD2970>
    1
    printing --> 1
    2
    printing --> 2
    3
#+END_EXAMPLE

#+BEGIN_SRC python
    # implicit next

    g1 = my_generator()
    print(f"Generator object --> {g1}")

    for x in g1:
        print(x)
        print('--')
#+END_SRC

#+BEGIN_EXAMPLE
    Generator object --> <generator object my_generator at 0x00BD2B30>
    1
    --
    printing --> 1
    2
    --
    printing --> 2
    3
    --
    printing --> 3
#+END_EXAMPLE

*Converting the Sentence to a generator function*

#+BEGIN_SRC python
    import re

    RE_WORD = re.compile('\w+')

    class Sentence:
        
        def __init__(self, text):
            self.text = text
            # you can also replace "findall" by "finditer" which is the lazy version of it. But then this statement goes in __iter__
            self.word = RE_WORD.findall(self.text)  
            self.index = 0
             
        def __iter__(self):
            for word in self.word:
                yield word
#+END_SRC

#+BEGIN_SRC python
    s = Sentence("Hello World today is Monday")

    iter1 = iter(s)
    iter2 = iter(s)

    print(next(iter1))
    print(next(iter2))  # We do not have that problem here, we can have 2 iterators on the s object individually.
#+END_SRC

#+BEGIN_EXAMPLE
    Hello
    Hello
#+END_EXAMPLE

#+BEGIN_SRC python
    iter1, iter2  # Check these out they are both independent objects thus they do not share the state.
#+END_SRC

#+BEGIN_EXAMPLE
    (<generator object Sentence.__iter__ at 0x00BD2B70>,
     <generator object Sentence.__iter__ at 0x00BD2830>)
#+END_EXAMPLE

*** Examples


Using a generator to capitalize sentence.

#+BEGIN_SRC python
    def capitalize(values):
        print(values)
        for value in values:
            yield value.upper()


    print("".join(capitalize('Hello Sir')))  # HELLO SIR
#+END_SRC

*** Sending data to generator using yield statement


#+BEGIN_SRC python
#+END_SRC

*** Generator Expression


Its a lazy version of list comprehension. =()= instead of =[]=

Generator expressions are syntactic sugar: they can always be replaced
by generator functions, but sometimes are more convenient. On the other
hand, generator functions are much more flexible: you can code complex
logic with multiple statements, and can even use them as coroutines.

#+BEGIN_SRC python
    import re

    RE_WORD = re.compile('\w+')

    class Sentence:
        
        def __init__(self, text):
            self.text = text
             
        def __iter__(self):
            # match.group() --> Returns one or more subgroups of the match
            #If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. 
            return (word.group() for word in RE_WORD.finditer(self.text))  # <-- This is a generator expression.
#+END_SRC

#+BEGIN_SRC python
    s = Sentence("The quick brown fox")

    for word in s:
        print(word)
#+END_SRC

#+BEGIN_EXAMPLE
    The
    quick
    brown
    fox
#+END_EXAMPLE

#+BEGIN_SRC python
    iter(s)  # returns a generator.
#+END_SRC

#+BEGIN_EXAMPLE
    <generator object Sentence.__iter__.<locals>.<genexpr> at 0x010C0330>
#+END_EXAMPLE

*Built in Generators*

There are lots of built in generators in Python e.g. the itertools
module provides some 19 generators to use e.g. =itertools.count= and
=itertools.takewhile=. Check out the official documentation to explore
more generators.

#+BEGIN_SRC python
    # Itertools.count is a generator
    import itertools
    itertools.count(1)  # Will run for ever
#+END_SRC

#+BEGIN_EXAMPLE
    count(1)
#+END_EXAMPLE

#+BEGIN_SRC python
    # Using itertools.takewhile with itertools.count --> 2 generators.
    gen = itertools.takewhile(lambda n: n<5,itertools.count(1))
    list(gen)
#+END_SRC

#+BEGIN_EXAMPLE
    [1, 2, 3, 4]
#+END_EXAMPLE

*** Yield From
    :PROPERTIES:
    :CUSTOM_ID: yield-from
    :END:

Introduced in Python 3.3 check out
[[https://www.python.org/dev/peps/pep-0380/][PEP380]] for more
information

#+BEGIN_SRC python
    s = 'ABC'
    n = (1,2,3)

    def chain(*iterables):
        for i in iterables:
            yield from i
            
    c = chain(s, n)
    c
#+END_SRC

#+BEGIN_EXAMPLE
    <generator object chain at 0x010C0530>
#+END_EXAMPLE

#+BEGIN_SRC python
    list(c)
#+END_SRC

#+BEGIN_EXAMPLE
    ['A', 'B', 'C', 1, 2, 3]
#+END_EXAMPLE


* Functions


** Attributes of a function


You can check attributes of a function by using the dir function
=dir(func)=. e.g. the =__dict__= attribute is used to store the user
attributes assigned to it.

#+BEGIN_SRC python
    def x(a = 2):
        a = 10
        b = 20

    >>> x.__dict__
    {}
#+END_SRC

Assigning arbitrary attributes to functions as shown below is not a very
common practice in general.

#+BEGIN_SRC python
    def x(a = 2):
        a = 10
        b = 20

    >>> x.a = 10
    >>> x.__dict__
    {'a': 10}
#+END_SRC

** Only positional arguments


=Python3= introduces only positional arguments for a function, you need
to put a =*= as shown below.

#+BEGIN_SRC python
    def main(*, a, b):  # This function will only take 2 keyword arguments
        return a + b

    >>> main(a = 10, b = 20)
    30
#+END_SRC

There can be various variations of it, e.g. =def main(a, *, b)= where
=a= is positional and =b= is keyword. Note that keyword-only arguments
do not need to have a default value: they can be mandatory.

** Inspect Module


You can do a lot with inspect module to check the code of the function
etc... e.g. checking the signature using =inspect.signature()=

** Functional programming modules


- =operator= module
- functools.partials

** Closures

A closure is a function with an extended scope that encompasses
nonglobal variables referenced in the body of the function but not
defined there. It does not matter whether the function is anonymous or
not; what matters is that it can access nonglobal variables that are
defined outside of its body.

#+BEGIN_SRC python
    # make averager using closures. This can also be done using class and __call__ method.
    def averager():
        series = []

        def ave(num):
            series.append(num)
            return sum(series)/len(series)

        return ave
#+END_SRC

Here you see that =ave= has closure over the =series= variable in the
=averager=.

#+BEGIN_SRC python
    >>> a = averager()
    >>>
    >>> a(10)
    10.0
    >>> a(1)
    5.5
    >>> a(123)
    44.666666666666664
#+END_SRC

Lets inspect the =a= for variables and free variables (which are not
bound to the local scope)

#+BEGIN_SRC python
    >>> a.__code__
    <code object ave at 0x000001D277E3C660, file "main.py", line 4>
    >>> a.__code__.co_varnames
    ('num',)
    >>> a.__code__.co_freevars
    ('series',)
    >>> a.__closure__
    (<cell at 0x000001D27829CF48: list object at 0x000001D2788111C8>,)
#+END_SRC

The binding for series is kept in the *closure* attribute of the
returned function. Each item in =a.__closure__= corresponds to a name in
=a.__code__.co_free vars=. These items are cells, and they have an
attribute called cell_contents where the actual value can be found.

#+BEGIN_SRC python
    >>> a.__closure__
    (<cell at 0x000001D27829CF48: list object at 0x000001D2788111C8>,)
    >>>
    >>> a.__closure__[0]
    <cell at 0x000001D27829CF48: list object at 0x000001D2788111C8>
    >>> a.__closure__[0].cell_contents
    [10, 1, 123]
#+END_SRC

To summarize: a closure is a function that retains the bindings of the
free variables that exist when the function is defined, so that they can
be used later when the function is invoked and the defining scope is no
longer available.

*** =nonlocal=
    :PROPERTIES:
    :CUSTOM_ID: nonlocal
    :END:

Consider the example below.

#+BEGIN_SRC python
    def outer():
        counter = 0

        def inner(num):
            counter += num
            return counter

        return inner


    my_counter = outer()

    my_counter(10)
#+END_SRC

When you run this python gives an error
=UnboundLocalError: local variable 'counter' referenced before assignment=.
The reason is that when you are trying to increment =counter += num= you
are treating it as a bounded variable and not as a free variable. So to
use that (and because counter is not a global variable) you need to use
the keyword =nonlocal=.

#+BEGIN_SRC python
    def outer():
        counter = 0

        def inner(num):
            nonlocal counter
            counter += num
            return counter

        return inner


    my_counter = outer()

    my_counter(10)
#+END_SRC

#+BEGIN_SRC python
    >>> my_counter(1)
    11
    >>> my_counter(12)
    23
#+END_SRC

** Decorators


#+BEGIN_SRC python

    def upper_case(function):
        def wrapper():
            func = function()
            uppercase = func.upper()
            return uppercase
        return wrapper


    def get_len(function):
        def wrapper():
            return len(function())
        return wrapper

    @get_len
    @upper_case
    def say_hi():
        return 'hi hello'



    print(say_hi())
#+END_SRC

Multiple decorators are applied from bottom to top.

#+BEGIN_SRC python
    from time import time , sleep

    def timer(function):
        def wrapper(*a, **kw):
            before = time()
            answer = function(*a, **kw)
            sleep(.00005)
            after = time()
            return after - before
        return wrapper

    @timer
    def adder(x, y):
        return x + y

    # adder = timer(adder)

    x = adder(10, 20)
    print(x)
#+END_SRC

*** When are decorators executed ?

A key feature of decorators is that they run right after the decorated
function is defined. That is usually at import time.

*** Decorators in standard library


- property
- classmethod
- staticmethod
- functools.lru_cache
- functools.singledispatch

*** Stacked decorators


*** Parameterized decorators


* Disassembler for Python bytecode


#+BEGIN_SRC python
    >>> import dis
    >>> dis.dis('s[a] += b')
      1           0 LOAD_NAME                0 (s)
                  2 LOAD_NAME                1 (a)
                  4 DUP_TOP_TWO
                  6 BINARY_SUBSCR
                  8 LOAD_NAME                2 (b)
                 10 INPLACE_ADD
                 12 ROT_THREE
                 14 STORE_SUBSCR
                 16 LOAD_CONST               0 (None)
                 18 RETURN_VALUE
#+END_SRC

* Decorators

#+BEGIN_SRC python
    """
    Simple decorator.
    """

    import functools

    def funcA():
        print("In func A")


    def decoratorA(func):
        def wrapper():
            print("In wrapper")
            return func()
        return wrapper


    funcA = decoratorA(funcA)
        
    @decoratorA
    def funcB():
        print("In funcB")


    # -------------------------------------------------
    # Doing something in the wrapper.


    import time


    def timerA(func):
        def wrapper():
            before = time.time()
            time.sleep(.0001)
            result = func()
            after = time.time()
            print(f'Time taken is {after - before}')
            return result
        return wrapper


    @timerA
    def funcC():
        print("Hello world")


    # ------------------------------------------------
    # What if the function accepts arguments.



    def timerB(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            before = time.perf_counter_ns()
            result = func(*args, **kwargs)
            after = time.perf_counter_ns()
            print(f'Time taken is {after - before}')
            return result 
        return wrapper

    @timerB
    def funcD(a, b):
        return a * b

    funcD(10, 12312312213321)



    # ------------------------------------------------
    # Decorator with arguments and function with arguments


    def repeat(num_times = 0):
        def decorator_repeat(func):
            @functools.wraps(func)
            def wrapper(*args, **kwargs):
                for i in range(num_times):
                    func(*args, **kwargs)
            return wrapper
        return decorator_repeat
        
        
    @repeat(num_times = 4)
    def add(x, y):
        print( x + y)


    # -----------------------------------------------
    # Using class as decorators.

    class Decorator:

        def __init__(self, func):
            self.func = func
        
        def __call__(self, *args, **kwargs):
            print("Before Function Call") 
            result = self.func(*args, **kwargs)
            print(result)
            print("After function call")
            return result
            

    @Decorator
    def sub(x, y):
        return x - y


    """
    Where can they be used in?
    - Timer functions
    - Logging functions
    - Plugin system
    - Authentication - is user logged in?
    - Singleton
    """


    """
    You can write class decorators as well i.e. which decorate the class and not functions
    e.g. check out the dataclass

    - Decorators can be stacked on top of each other.
    """

    # In some cases it may be usefull to keep track of the state in a decorator.
    # In the example below we add num_calls as a variable of a function itself.


    def count_calls(func):
        @functools.wraps(func)
        def wrapper_count_calls(*args, **kwargs):
            wrapper_count_calls.num_calls += 1  # same as wrapper_count_calls.variable 
            print(f"Call {wrapper_count_calls.num_calls} of {func.__name__!r}")
            return func(*args, **kwargs)
        wrapper_count_calls.num_calls = 0
        return wrapper_count_calls

    @count_calls
    def x():
        pass

    @count_calls
    def y():
        pass

    # Will track the state for x and y separately.
    x()
    x()
    y()
    y()
#+END_SRC

** Common usages

- Argument Checking
- Caching
- Proxy
- Context Provider
- Debugging

* Data Model Methods

There are many data model or special methods in Python, a handfull of
them are covered below. For details of other methods please check out
this ref link from
[[https://docs.python.org/3/reference/datamodel.html][python docs]]

** =__getitem__=


The =__getitem__= function if implemented on a class will support the
following - object[0] - get by position - you can use the standard
=random.choice()= to get any from the object. - slicing =object[x:y]=

#+BEGIN_SRC python
    # __getitem__ example

    import collections
    from random import choice

    Card = collections.namedtuple('Card', ('rank', 'suit'))

    class FrenchDeck:
        ranks = [str(n) for n in range(2, 11)] + list('JQKA')
        suits = "spades diamonds clubs hearts".split(" ")

        def __init__(self):
            self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]

        def __len__(self):
            return len(self._cards)

        def __getitem__(self, position):
            return self._cards[position]


    if __name__ == "__main__":
        deck = FrenchDeck()
        print(len(deck))
        print(deck[4])
        print(deck[4:10])
        print(choice(deck))
        print(Card('Q', 'hearts') in deck)
#+END_SRC

Slicing can return only the array but if you want slicing to return a
new object of that class but only sliced entries then you have to
implement something like this where =components= are arrays.

#+BEGIN_SRC python
    def __len__(self):
        return len(self._components)

    def __getitem__(self, index):
        cls = type(self)
        if isinstance(index, slice):
            return cls(self._components[index])
        elif isinstance(index, numbers.Integral):
            return self._components[index]
        else:
            msg = '{cls.__name__} indices must be integers'
            raise TypeError(msg.format(cls=cls))
#+END_SRC

If there is no =__iter__= python falls back on =__getitem__= for
iteration.

If there is no =__contains__= python falls back on =__getitem__= to
check for =x in y=.

** =__repr__=


Provides the string representation of the object. The representation
should match the source code needed to recreating this instance.

** =__str__=


=__str__= is called by the =str()= and implicitly used by the print
statement. This should return a string suitable for end users. The
differnce between =__str__= and =__repr__= is illustrated by this
example below.

If you only implement one of these special methods, choose =__repr__=,
because when no custom =__str__= is available, Python will call
=__repr__= as a fallback.

#+BEGIN_SRC python
    class Point:

        def __init__(self, x, y):
            self.x = x
            self.y = y

        def __repr__(self):
            return 'Point({}, {})'.format(self.x, self.y)

        def __str__(self):
            return 'Point at {} and {}'.format(self.x, self.y)
#+END_SRC

#+BEGIN_SRC python
    >>> p1 = Point(2, 10)
    >>> p1
    Point(2, 10)
    >>> print(p1)
    Point at 2 and 10
#+END_SRC

** =__abs__=


gives absolute value

** =__add__=

Addition of 2 objs

** =__mul__=

Multiplication of 2 objs

** =__bool__=


Python will accept any object in boolean context because it calls
=__bool__= to determine /truthy or falsy/

** =__del__=


Python will call the =__del__= method (if defined) on an object before
destroying it. (When the reference count reaches 0). This is for Cpython
which uses the reference counting and not all implementation of python
e.g. Pypy which uses garbage collection (this *del*) may not be called
immidiately.

** =__format__=


With datetime you can work with printing specific formats like
=>>> format(now, '%H:%M:%S')= and with float values you can use as
below.

#+BEGIN_SRC python
    pi = 22/7
    print(f'{pi:.4f}')
#+END_SRC

The =__format__= function lets you define your own format for your
object.

** =__hash__=


Make your objects hashable. Check example from fluent python

** =__getattr__=


=__getattr__= allows you to specify custom attributes on your object
which can get values of your elements in the class. e.g. n-d vector may
choose to implement x, y, z e.g. v.x v.y and v.z for first few
dimensions of it...

** =__setattr__=

along with getattr you may need to implement setattr in certain
scenarios.

=super().__setattr__(name, value)=

You can also use setattr to restrict setting any other/or any specific
attributes on that class as shown below.

#+BEGIN_SRC python
    # cannot set any attribute on the class.
    class X:

        def __setattr__(self, name, val):
            msg = "Cannot add any other attributes"
            raise Exception
#+END_SRC

** =__iter__=

=__iter__= is a generator function which, when called, builds a
generator object that implements the iterator interface.

** =__hash__=


provides the =hash= of an object.

* Copy

Copies are shallow by default.

Example of shallow copy, even though =l1= and =l2= the id is different
their inner list refers to the same list so appending 10 to l1 appends
it to l2 as well.

#+BEGIN_SRC python
    In [15]: l = [1, [1]]

    In [16]: l1 = [1, [1]]

    In [17]: l2 = list(l1)

    In [18]: l1[1].append(10)

    In [19]: l1
    Out[19]: [1, [1, 10]]

    In [20]: l2
    Out[20]: [1, [1, 10]]

    In [21]: id(l1)
    Out[21]: 2159380834888

    In [22]: id(l2)
    Out[22]: 2159379541128
#+END_SRC

You can use the following for copying - Shallow copy - =copy.copy()= -
Deep copy - =copy.deepcopy()=

In order for a class to define its own copy implementation, it can
define special methods =__copy__()= and =__deepcopy__()=

*Tip* - Never have mutable types as defualt parameters of your
arguments.

* Context Managers

The =with= statement sets up a temporary context and reliably tears it
down. The =with= statement was designed to simplify the try/finally
pattern which gaureentees even if the block is aborted even because of
an exception the finally clause will release the critical resource.

The context manager works with =__enter__= and =__exit__= protocol.

*Usage*

The context manager should be used for common setup and tear down code,
which is not just applicable for files. There can be various uses for
it.

#+BEGIN_SRC python
    # Sample context manager for file.

    class File:
        
        def __init__(self, file, method):
            self.file = open(file, method)
            
        def __enter__(self):
            return self.file  # returns the object which will sit in "f" --> with File(abc.txt, w) as "f"
        
        def __exit__(self, exception_type, exception_value, traceback):   # The exit must take in these 4 params else it raises exception
            self.file.close()
#+END_SRC

The context manager which you see above provides a pattern of
=__enter__= and =__exit__=. However if you see there is no exception
which is handled here. One way is to handle exceptionions manually...

#+BEGIN_SRC python
    # Another example of a context manager.

    import time

    class Timer:
        
        def __enter__(self):
            self.start = time.time_ns()
            return self
            
        def __exit__(self, exception_type, exception_value, traceback):
            self.end = time.time_ns()
            self.processing_time = self.end - self.start
            
#+END_SRC

#+BEGIN_SRC python
    with Timer() as t:
        time.sleep(.1)
        for i in range(10):
            print(i)
        
    t.processing_time
#+END_SRC

#+BEGIN_EXAMPLE
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9





    100219600
#+END_EXAMPLE

--------------

** contextmanager

Handling all sorts of exceptions can be difficult so python has provided
with a decorator that turns a generator function into a context manager.
Because think of it =__enter__= is starting something and pausing and
then =__exit__= takes over when we have to tear it down or finish the
work which is exactly what a generator does it yeilds and waits.

You can use the =contextlib= library to import the =contextmanager=
decorator to turn your generator into a context manager.

Go and check out the code of =contextmanager= it does handle a lot of
exceptions and makes it easier to create a context manager and do away
with the =__enter__= and =__exit__= protocol.

#+BEGIN_SRC python
    from contextlib import contextmanager
    import time

    @contextmanager
    def timer():
        start = time.time_ns()
        yield  # same concept it should return something which goes into the with "as" variable.
        end = time.time_ns()
        print(f"Time taken in ns = {end - start}")
        
    with timer() as t:
        time.sleep(.1)
        for i in range(10):
            print(i)
#+END_SRC

#+BEGIN_EXAMPLE
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9
    Time taken in ns = 100953200
#+END_EXAMPLE

#+BEGIN_SRC python
    @contextmanager
    def file_manager(f):
        file = open(f)
        yield  file # same concept it should return something which goes into the with "as" variable.
        file.close()
        print("File closed")
#+END_SRC

#+BEGIN_SRC python
    with file_manager("django.md") as f:
        print(f.readlines())
#+END_SRC

#+BEGIN_EXAMPLE
    ['# Forms\n', '\n', '### Formsets\n', '\n', '\n', 'Create a simple model with few fields.\n', '\n', '```python\n', '# models.py\n', '\n', 'class Employee(models.Model):\n', '\n', '    name = models.CharField(max_length=40)\n', '    is_manager = models.BooleanField(default=False)\n', '    email = models.CharField(max_length = 100)\n', '\n', '    def __str__(self):\n', '        return self.name\n', '```\n', '\n', 'After creating a model, lets create a model form for that model. Also create the formset for that model and form as shown below.\n', '\n', '```python\n', '# forms.py\n', '\n', 'from django import forms\n', 'from .models import *\n', 'from django.forms import modelformset_factory\n', '\n', '\n', 'class EmployeeForm(forms.ModelForm):\n', '    email = forms.EmailField(disabled=True)  # disable field\n', '\n', '    class Meta:\n', '        model = Employee\n', "        fields = ['email', 'name', 'is_manager']\n", '\n', '\n', 'EmployeeFormSet = modelformset_factory(Employee, form=EmployeeForm, max_num=0)\n', '\n', '```\n', '\n', 'Use the formset created in the view.\n', '\n', '```python\n', '# views.py\n', '\n', 'from django.shortcuts import render\n', 'from .forms import *\n', 'from django.views import View\n', 'from .models import *\n', '\n', '\n', 'def index(request):\n', '    context = {}\n', "    if request.method == 'GET':\n", '        \n', '        formset = EmployeeFormSet()\n', "        return render(request, 'tryformsets/index.html', {'formset' : formset})\n", '\n', "    if request.method == 'POST':\n", '\n', '        # formset = EmployeeFormSet(request.POST or None, request.FILES or None)\n', '        formset = EmployeeFormSet(request.POST)\n', '        if formset.is_valid():\n', '            formset.save()\n', '        formset = EmployeeFormSet()\n', "        return render(request, 'tryformsets/index.html', {'formset' : formset})\n", '\n', '```  \n', '\n', 'Then create the template and use the formset. Make sure to include the `{{formset.management_form}}` else it gives error. For more information check the [link](https://docs.djangoproject.com/en/2.2/topics/forms/formsets/#understanding-the-managementform)\n', '\n', '```html\n', '<form method="POST" action=".">{% csrf_token %}\n', '\n', '    {{ formset.management_form }}\n', '\n', '    <table class="table">\n', '        <thead>\n', '            <tr>\n', '                <th>Name</th>\n', '                <th>Item Name</th>\n', '                <th>Item Price</th>\n', '            </tr>\n', '        </thead>\n', '        {% for form in formset %}\n', '\n', '        <tbody>\n', '            {{ form.id }}\n', '            <tr>\n', '                <td>{{ form.name }}</td>\n', '                <td>{{ form.email }}</td>\n', '                <td>{{ form.is_manager }}</td>\n', '            </tr>\n', '            {% endfor %}\n', '        </tbody>\n', '\n', '    </table>\n', '    <button type="submit">Submit</button>\n', '</form>\n', '```\n', '\n', '<hr>\n', '\n', '## Working with DB\n', '\n', '### Bulk Update\n', '\n', '```python\n', '# Coverage is a model which we need to update in bulk.\n', '# Here we are trying to update the rows with pk = 33, 34 and 35 with different values.\n', '>>> objs = []\n', '>>> objs.append(Coverage.objects.get(pk = 33))                                             \n', '>>>                                                                                        \n', '>>> objs.append(Coverage.objects.get(pk = 34))                                             \n', '>>> objs.append(Coverage.objects.get(pk = 35))                                             \n', '>>>                                                                                        \n', '>>> objs[1].coverage_needed = True                                                         \n', '>>>                                                                                        \n', '>>> objs[1].coverage_needed                                                                \n', 'True                                                                                       \n', '>>>                                                                                        \n', '>>> objs[2].coverage_needed                                                                \n', 'False                                                                                      \n', '>>>                                                                                        \n', '>>> objs[0].unavailable = True                                                             \n', '>>>                                                                                        \n', '>>> objs[2].supply_called = True                                                           \n', '>>>                                                                                        \n', ">>> Coverage.objects.bulk_update(objs, ['coverage_needed', 'supply_called', 'unavailable'])\n", '```\n', '\n', '## Links\n', '\n', '### Forms\n', '\n', '- [DataTable Editable](https://stackoverflow.com/questions/56290703/django-edit-html-table-rows-and-update-database)\n', '- [Django Forms - HTML](https://stackoverflow.com/questions/39183155/django-with-html-forms)\n', '- [Django Forms - Rendering each form element manually for better styling.](https://simpleisbetterthancomplex.com/article/2017/08/19/how-to-render-django-form-manually.html)\n', '\n', '\n', '\n']
    File closed
#+END_EXAMPLE

There could be certain cases where you need to handle and tackle
excpetions manually or have some explicit requirements which are better
suited in class then you can go ahead and use the traditional way.

* Collections

** Queue & Deque

*** Deque

The class collections.deque is a thread-safe double-ended queue designed
for fast inserting and removing from both ends.

#+BEGIN_SRC python
    >>> from collections import deque
    >>> dq = deque(range(10), maxlen=10)
    >>> dq
    deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
    >>> dq.rotate(3)
    >>> dq
    deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)
    >>> dq.rotate(-4)
    >>> dq
    deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)
    >>> dq.appendleft(-1)
    >>> dq
    deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
    >>> dq.extend([11, 22, 33])
    >>> dq
    deque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10)
    >>> dq.extendleft([10, 20, 30, 40])
    >>> dq
    deque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10)
#+END_SRC

** Other queues


There are multiple other types of queues which are supported by Python

- queue
- multiprocessing --> Queue
- asyncio --> Queue, LifoQueue, PriorityQueue, JoinableQueue

** Named Tuples


Creating named tuples is easy.

=nt = namedtuple('t', ('a', 'b'))= - Where 't' is the name of named
tuple - =a= and =b= are parameters

namedtuple can be used to build classes of objects that are just bundles
of attributes with no custom methods, like a database record.

#+BEGIN_SRC python

    import collections

    Student = collections.namedtuple('Student', ('name', 'age', 'id'))

    sam = Student("Sam", 10, 11)

    print(sam)
    print(sam.name)
    print(sam.age)
#+END_SRC

You can check the fields of a named tuple using =_fields=

#+BEGIN_SRC python
    >>> Student._fields
    ('name', 'age', 'id')
#+END_SRC

- Named tuples can be nested in another named tuples.

Other useful methods

*=_asdict()=*

#+BEGIN_SRC python
    >>> sam = Student("Sam", 10, 11)
    >>> 
    >>> sam._asdict()
    OrderedDict([('name', 'Sam'), ('age', 10), ('id', 11)])
#+END_SRC

*=_make()=* _make() allow you to instantiate a named tuple from an
iterable

*** Why can some tuples be hashed and some do not?

Tuples are immutable objects (by themselves). However tuples can contain
lists which are mutable (and cannot be hashed). Thus you get the
scenario below.

#+BEGIN_SRC python
    In [7]: t1 = (1)

    In [8]: t2 = ([1])

    In [9]: hash(t1)
    Out[9]: 1

    In [10]: hash(t2)
    ---------------------------------------------------------------------------
    TypeError                                 Traceback (most recent call last)
    <ipython-input-10-c1655d61dc02> in <module>
    ----> 1 hash(t2)

    TypeError: unhashable type: 'list'
#+END_SRC


* Callables

The =__call__= has a syntactic operator =()=. To check if the object is
callable use the =callable()= buit in function.

The python data model lists 7 types of callable types.

- User Defined Functions like named or lambda functions
- Built in functions like =len=\\
- Buit in methods like dict.get
- Methods of a class
- Classes. (When invoked it runs =__new__= and then =__init__= )
- Classes instalce --> If the class has a =__call__= method
- Generator functions --> use =yield=
- There are other 2 as well but they deal with async and co-routines
  check this link for further details.
  [[https://docs.python.org/3/reference/datamodel.html][Link]]

You can implement =__call__= method and make objects callable
e.g. example given below. This is an interesting way to implement
function like callables which need an internal state. This can also be
done with the help of a =closure=.

#+BEGIN_SRC python
    from random import randint

    class RandomNumber:

        def __init__(self):
            self.calls = 0


        def __call__(self):
            self.calls += 1
            return randint(1, 100)   
#+END_SRC

Testing

#+BEGIN_SRC python
    >>> r = RandomNumber()
    >>> r()
    62
    >>> r()
    28
    >>> r.calls
    2
#+END_SRC
